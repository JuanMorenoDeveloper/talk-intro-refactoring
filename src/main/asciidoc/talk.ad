= Introducción a Refactoring
:icons: font
:twitter-tag: ACCSA
:conference-tag:
:talk-tag: Intro Refactoring
:linkattrs:

include::footer.ad[]

[NOTE.speaker]
====
Contenido de la presentación:

* Secciones teóricas:
**  Código legacy
**  Razones para cambiar un software.
**  Testing
**  Algoritmo para cambiar código legacy
**  Herramientas
**  Sprout Method
**  Sprout Class
**  Wrap Method
**  Wrap Class
* Sección práctica:
**  Sprout Method
**  Sprout Class

====

== Contenido
* Fundamentos
* ¿Cómo cambiar código legacy?
* Herramientas
* Técnicas

== Todos tenemos buenas intenciones

== !

image::good-intentions1.jpg[background, size=auto]
//Fuente: http://kfaday.blogspot.com/2016/01/la-vida-de-un-ingeniero-de-sistemas.html

== Pero...

== !

image::good-intentions2.jpg[background, size=auto]

== Código legacy

== !

image::legacy-code.jpeg[background, size=auto]

== ¿Qué es código legacy? icon:lightbulb[]

* ¿Código de "otros"?
* ¿Código díficil de entender?
* ¿Código díficil de mantener?
* ...

== !

> Código legacy es código sin tests.

> (2004) M. Feather

[NOTE.speaker]
====
Code without tests is bad code. It doesn’t matter how well written it is; it doesn’t matter how pretty or object-oriented or well-encapsulated it is. With tests, we can change the behavior of our code quickly and verifiably. Without them, we really don’t know if our code is getting better or worse.
====

== Razones para cambiar un software

1. Agregar una feature
2. Reparar un bug
3. Mejorar el diseño
4. Optimizar el uso de recursos

[NOTE.speaker]
====
* Behavior is the most important thing about software. It is what users depend on.
Users like it when we add behavior (provided it is what they really wanted), but if we change or remove behavior they depend on (introduce bugs), they stop trusting us.

* The act of improving design without changing its behavior is called refactoring.

* Refactoring focus in program structure.

* Optimization focus in resources.

====

== !

|===
|                | *Adding a Feature* | *Fixing a Bug* | *Refactoring* | *Optimizing* |
| Structure      | Changes          | Changes      | Changes     | --         |
| Functionality  | Changes          | Changes      | --          | --         |
| Resource Usage | --               | --           | --          | Changes    |
|===

[NOTE.speaker]
====
Preserving existing behavior is one of the largest challenges in software development. Even when we are changing primary features, we often have very large areas of behavior that we have to preserve.
====

== Riesgos del cambio

1. ¿Cuáles cambios tenemos que hacer?
2. ¿Cómo sabremos que los cambios fueron hechos correctamente?
3. ¿Cómo sabremos que no hemos roto nada?

== Edit and Pray

¿Estándar de la industria?

== Cover and Modify

*Tests*

[NOTE.speaker]
====
When we have tests that detect change, it is like having a vise around our code. The behavior of the code is fixed in place. When we make changes, we can know that we are changing only one piece of behavior at a time. In short, we’re in control of our work.
====

== ¿Muchas dependencias?

image::invoice-example.png[background, size=auto]

[NOTE.speaker]
====
Dependency is one of the most critical problems in software development. Much legacy code work involves breaking dependencies so that change can be easier.
====

== El dilema del código legacy

Cuando cambiemos el código, deberíamos tener pruebas en su lugar. Para realizar pruebas, a menudo tenemos que cambiar el código.

== Rompiendo dependencias
image::invoice-dependency-broken.png[background, size=auto]

[NOTE.speaker]
====
Cuando se rompen dependencias en código legacy, a menudo tiene que suspender un poco su sentido de la estética. Algunas dependencias se rompen limpiamente; Otros terminan pareciendo menos ideales desde el punto de vista del diseño. Son como los puntos de incisión en la cirugía: es posible que quede una cicatriz en su código después de su trabajo, pero todo lo que esté debajo puede mejorar.
====

== El algoritmo para cambiar código legacy

1. Identificar puntos de cambio.
2. Encontrar puntos de test.
3. Romper dependencias.
4. Escribir tests.
5. Hacer cambios y refactorizar.

== Técnicas

== No tengo mucho tiempo y necesito cambiar el código

[NOTE.speaker]
====
*It Happens Someplace Every Day*
You boss comes in. He says, “Clients are clamoring for this feature. Can we get it done today?”

“I don’t know.”

You look around. Are there tests in place? No.

You ask, “How bad do you need it?”

You know that you can make the changes inline in all 10 places where you need to change things, and it will be done by 5:00. This is an emergency right? We’re going to fix this tomorrow, aren’t we?
Remember, code is your house, and you have to live in it
====

== Sprout method

```java
public class TransactionGate {
  public void postEntries(List entries) {
    List entriesToAdd = new LinkedList();
    for (Iterator it = entries.iterator(); it.hasNext(); ) {
      Entry entry = (Entry)it.next();
      if (!transactionBundle.getListManager().hasEntry(entry) {
          entry.postDate();
          entriesToAdd.add(entry);
      }
    }
    transactionBundle.getListManager().add(entriesToAdd);
  }
  //...
}
```

== Agregar feature

Verificar las nuevas entradas no estén previamente en `transactionBundle`

== Extrayendo lógica a método
```java
public class TransactionGate {
//...
  List uniqueEntries(List entries) {
    List result = new ArrayList();
    for (Iterator it = entries.iterator(); it.hasNext(); ) {
      Entry entry = (Entry)it.next();
      if (!transactionBundle.getListManager().hasEntry(entry) {
          result.add(entry);
      }
    }
    return result;
  }
//...
}
```

== Funcionalidad incorporada

```java
public class TransactionGate{
//...
  public void postEntries(List entries) {
    List entriesToAdd = uniqueEntries(entries);
    for (Iterator it = entriesToAdd.iterator(); it.hasNext(); ) {
      Entry entry = (Entry)it.next();
      entry.postDate();
    }
    transactionBundle.getListManager().add(entriesToAdd);
  }
//...
}
```

== Implementando el método sprout
1. Identificar
2. Agregar la referencia en el código
3. Entradas y salidas como argumentos
4. Identificar valores de retorno
5. Implementación del método vía TDD
6. Eliminar comentario y habilitar la llamada.

[NOTE.speaker]
====
1. Identifique dónde necesita cambiar su código.
2. Si el cambio se puede formular como una secuencia única de declaraciones en un lugar en un método, escriba una llamada para un nuevo método que hará el trabajo involucrado y luego coméntelo. (Hacer esto incluso antes de escribir el método para poder tener una idea de cómo se verá el llamado del método en el contexto).
3. Determine qué variables locales necesita del método de origen y conviértalos en argumentos para la llamada.
4. Determine si el método sprout deberá devolver los valores al método de origen. Si es así, cambie la llamada para que su valor de retorno se asigne a una variable.
5. Desarrollar el método sprout de utilizando TDD.
6. Elimine el comentario en el método de origen para habilitar la llamada.
====

== Ventajas del método sprout
* Clara separación entre el código anterior y el nuevo.
* Se pueden identificar las variables afectadas.
* El nuevo método incluye tests.

== Desventajas del método sprout
* Puede dejar el método original en un estado raro (invocaciones a funciones externas).
* Puede dejar el código en un limbo (El nuevo método puede no estar asociado a la responsabilidad del código original)

== Sprout class

```cpp
std::string QuarterlyReportGenerator::generate() {
  std::vector<Result> results = database.queryResults(
  beginDate, endDate);
  std::string pageText;
  pageText += "<html><head><title>"
  "Quarterly Report"
  "</title></head><body><table>";
  if (results.size() != 0) {
    for (std::vector<Result>::iterator it = results.begin();it != results.end();++it) {
      pageText += "<tr>";
      pageText += "<td>" + it->department + "</td>";
      pageText += "<td>" + it->manager + "</td>";
      char buffer [128];
      sprintf(buffer, "<td>$%d</td>", it->netProfit / 100);
      pageText += std::string(buffer);
      sprintf(buffer, "<td>$%d</td>", it->operatingExpense / 100);
      pageText += std::string(buffer);
      pageText += "</tr>";
    }
  } else {
    pageText += "No results for this period";
  }
  pageText += "</table>";
  pageText += "</body>";
  pageText += "</html>";
  return pageText;
}
```

== Agregar feature

Agregar una cabecera al listado del tipo

```html
<tr><td>Department</td><td>Manager</td><td>Profit</td><td>Expenses</td></tr>
```

== Extrayendo lógica a clase

```cpp
using namespace std;
class QuarterlyReportTableHeaderProducer{
  public:
    string makeHeader();
};

string QuarterlyReportTableProducer::makeHeader(){
  return "<tr><td>Department</td><td>Manager</td>”
  "<td>Profit</td><td>Expenses</td>”;
}
```

== Agregamos invocación al método original

```cpp
QuarterlyReportGenerator::generate():
//...
QuarterlyReportTableHeaderProducer producer;
pageText += producer.makeHeader();
//...
```
== ¿Es en serio? Un método para esto

== Sí

== Permite hacer refactoring adicionales

== Una interfaz

```cpp
class QuarterlyReportTableHeaderGenerator{
  public:
  string generate();
};
```

== Diferentes implementaciones

```cpp
class HTMLGenerator{
  public:
    virtual ~HTMLGenerator() = 0;
    virtual string generate() = 0;
};

class QuarterlyReportTableHeaderGenerator : public HTMLGenerator {
  public:
  //...
    virtual string generate();
  //...
};
class QuarterlyReportGenerator : public HTMLGenerator {
  public:
  //...
    virtual string generate();
  //...
};
```
== Implementando la clase sprout

1. Identifique dónde necesita cambiar su código.
2. ¿Se puede agrupar en un método? Piense en un nombre de clase e invoque al método. Comente la invocación.
3. Variables y argumentos.
4. Valores de retorno.
5. Desarrolle la clase sprout usando TDD.
6. Elimine el comentario y haga la invocación.

[NOTE.speaker]
====
1. Identifique dónde necesita cambiar su código.
2. Si el cambio se puede formular como una secuencia única de declaraciones en un lugar en un método, piense en un buen nombre para una clase que podría hacer ese trabajo. Luego, escriba el código que crearía un objeto de esa clase en ese lugar y llame a un método que haga el trabajo que necesita hacer; Luego comenta esas líneas.
3. Determine qué variables locales necesita del método de origen y conviértalos en argumentos para el constructor de las clases.
4. Determine si la clase brotada deberá devolver los valores al método de origen. Si es así, proporcione un método en la clase que proporcionará esos valores y agregue una llamada en el método de origen para recibir esos valores.
5. Desarrolle primero la prueba de la clase de brotes (vea desarrollo dirigido por pruebas)
6. Elimine el comentario en el método de origen para habilitar la creación de objetos y las llamadas.
====

== Ventajas de la clase sprout
* Permite avanzar en el desarrollo con más confianza que si haces cambios invasivos.

== Desventajas de la clase sprout
* Complejidad conceptual.

== ¿Hay más técnicas?

== Sí

== Las veremos más adelante...

== Conclusiones

* Trabajar con código legacy es díficil
* Los tests son necesarios
* Cuando no se puede prevenir la enfermedad, se tiene que tratar
* Las técnicas ayuda, pero su aplicación depende del contexto

include::self.ad[]
